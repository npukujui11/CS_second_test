## 绪论
### **数据结构具体有哪几种？**
* 线性结构：线性表、栈、队列、字符串；
* 非线性结构：二叉树、森林、图；

## 线性表
### **数据结构中的链表的逆置？**
* 头插法：初始化一个指针s，指向链表的头结点，然后用循环遍历链表，每次把s指向的结点插入到链表的最前端；

### **数组和链表的区别**
* 从最底层的存储结构上来看，数组的存储结构是一块连续的内存空间，链表则是一组零散的内存块串联在一起；
* 根据底层存储结构可以知道，数组的插入和删除操作的时间复杂度是O(n)，随机访问的时间复杂度是O(1)；而链表的插入和删除操作时间复杂度是O(1),随机访问的时间复杂度是O(n);
* 同样的数据存储量，链表对存储空间的消耗更大，因为链表中的每一个结点都需要消耗额外的存储空间去存储下一个结点的指针；
* 在实际应用中，对链表进行频繁的插入、删除操作，会导致频繁的内存申请和释放，从而产生内存碎片；

### **双向链表删除当前结点**
* ![avatar](picture/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9.jpg)
```
p->prior->next = p->next;
p->next->prior = p->prior;
```

### **一个链表里面有循环，怎么确定循环的头尾相交结点？**
* 如果允许修改结点的数据结构的话，那么就在每个结点上设置一个标志位表示是否被访问过。这样遍历时遇到已访问结点即是循环的第一个点；
* 如果不允许修改结点，那么就在外部用一个hashmap记录下所有的已访问的结点。遍历时先查找这个hashmap，如果结点不存在，就把该结点加入hashmap，如果存在，说明该结点就是循环的第一个结点；

### **一个链表里面有循环，怎么确定循环的头尾相交结点？（如何确定链表有环？）**
* 遍历法：两层循环，每到一个结点，就从头开始在遍历到当前结点的前一个，看有无与这个结点相同的；
* 快慢指针法：两个指针，一个每次走一步，一个每次走两步，若两者相遇，则有环；
* Hash表法：每遍历一个结点，就把这个结点的id与哈希表中的比较，若没有，则存入，反之，则有环

## 栈和队列

### **队列和链表相比缺点**
* 优点：空间使用少一个头结点空间；
* 缺点：对于顺序队列，空队列或者一个结点时插入和删除操作略复杂；

### **如何实现循环队列，优点是什么？**
* 将存储队列元素的表从逻辑上看成一个环，称为循环队列。同时需要牺牲一个单元来区分队空和队满。
* 优点是循环队列不会出现溢出的情况

### **函数为什么使用栈**
* 函数调用之所以使用栈，是因为函数中经常会使用嵌套，也就是相互之间的调用关系，这需要用到动态存储区的栈结构；
* 例如：A调用B，B又调用C，那么需要C先执行，然后结果赋值给B中的临时变量，B的执行结果再赋值给A的临时变量，嵌套越深的函数越需要被先执行，这样的特征刚好符合栈的特点，因此每次遇到函数调用，只需要压栈，最后依次从栈顶弹出，依次执行即可。
* tips：栈的本质上是受限的线性表，具有后进先出，先进后出的特性；栈的一些运用场景，浏览器的前进后退功能、编译器利用栈来实现表达式求值、括号匹配；

## 串
### **模式匹配算法**
* 模式匹配算法是数据结构中字符串的一种基本运算，给定一个子串，要求在某个字符串中找出与该字串相同的所有字串；

### **$KMP$算法的基本思想？**
* 在暴力匹配中，每趟匹配失败都是模式后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行自我比较，这也是低效率的根源。因此，可以从分析模式本身的结构着手，如果已匹配相等的前缀序列中有某个后缀正好是模式的前缀，那么就可以将模式向后滑动到与这些相等字符对齐的位置，主串i指针无需回溯，并继续从该位置开始进行比较。而模式向后滑动位数的计算仅与模式本身的结构有关，与主串无关。

## 树与二叉树

### **二叉树和结点只有两个孩子的树的区别？**
* 二叉树中每个元素的的子树都是有序的，也就是说，可以用左、右子树来区别。树的两个孩子没有左右之分。

### **解释什么是二叉树，如何遍历**
* 二叉树是一种树型结构，它的特点是每个结点至多只有两颗子树（即二叉树中不存在度大于2的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。
* 前序遍历：
    + 前序遍历是指，对于树中的任意结点来说，先打印这个结点，然后再打印它的左子树，最后打印它的右子树；
    + ```C
        void preOrder(Node* root){
            if(root==NULL) return;
            print root;
            preOrder(root->left);
            preOrder(root->right);
        }```
* 中序遍历:
    + 中序遍历是指，对于树中的任意结点来说，先打印它的左子树，然后再打印本身，最后打印它的右子树；
    + ```C
        void preOrder(Node* root){
            if(root==NULL) return;
            preOrder(root->left);
            print root;
            preOrder(root->right);
        }```
* 后序遍历：
    + 后续遍历是指，对于树中的任意结点来说，先打印它的左子树，然后再打印它的右子树最后打印这个结点本身； 
    + ```C
        void preOrder(Node* root){
            if(root==NULL) return;
            preOrder(root->left);
            preOrder(root->right);
            print root;
        }```

### **树的存储结构**
* 双亲表示法：采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。
* 孩子表示法：孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表。缺点也很明显，寻找父亲结点时，需要遍历n个结点中孩子链表指针域所指向的n个孩子链表；
* 孩子兄弟表示法：即二叉树表示法，每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针；
    + ![avatar](picture/孩子兄弟表示法结点结构.gif)
    + 好处是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子、兄弟等，但是查找父亲结点比较麻烦；

### **什么是满二叉树？**
* 满二叉树就是除了最后一层无任何子结点外，每一层上的所有结点都有两个子结点的二叉树。

### **什么是二叉排序树？什么是平衡二叉树？如何调整？
* 二叉排序树：二叉排序树是一种具有用中序遍历为递增有序的树；
* 平衡二叉树：左右子树的高度之差绝对值不超过1的树；平衡二叉树的目的是为了解决二叉排序树因为动态更新导致的性能退化问题；所谓“平衡”的意思等价于性能不退化，“近似平衡”等价为性能不会退化得太严重
* 平衡二叉树在插入过程中会因为插入一个结点而导致出现不平衡的现象，因此需要在每一次插入新结点后进行判断调整，调整方法分为四种类型：
    + 右单旋转(LL)：结点左孩子的左子树上插入了新的结点导致不平衡，此时需要进行一次右旋操作恢复平衡；
    + 左单旋转(RR)：结点右孩子的右子树上插入了新的结点导致不平衡，此时需要进行一次左旋操作恢复平衡；
    + 先左后右双旋转(LR)：结点的左孩子和右子树上插入了新的结点导致不平衡，此时需要先进行一次左旋转操作，再进行一次右旋转操作恢复平衡；
    + 先右后左双旋转(RL)：结点的右孩子的左子树上插入了新的结点导致不平衡，此时需要先进行一次右旋转操作，再进行一次左旋转操作恢复平衡；

### **如何对树进行层序遍历？**
* 层序遍历需要用到队列。首先将树得根结点入队，然后出队时将出队结点的左右子结点入队，循环这个过程；

### **二叉排序树如何增删？**
* 插入过程类似于查找操作。如果要插入的数据比结点的数据大，并且结点的右子树为空，就将新数据直接插到右子结点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比结点数值小，并且结点的左子树为空，就将新数据插入到左子结点的位置；如果不为空，就再递归遍历左子树，查找插入位置。 
* 删除操作。如果删除的结点是叶子结点则直接删除，若删除结点只有一个子结点则用其代替，如果有两个结点的话，就**用右孩子结点的中序遍历的第一个结点代替**；

### **哈夫曼树是什么？作用是什么？
* 哈夫曼树：在含有n个带权结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树；
* 哈夫曼编码：对一颗具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的通路上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。哈夫曼编码是最优前缀码，常用于数据压缩处理；
* 如何构建哈夫曼树？
    + 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。
    + 构造一个新结点，从F中选取两颗根节点权值最小的树作为新结点的左、右子树，并且将新结点的权重置为左、右子树上根结点的权值之和。
    + 从F中删除刚才选出的两棵树，同时将新得到的树假如F中。
    + 重复上述两个步骤，直至F中只剩下一棵树为止。

## 图

### **图的存储结构有哪些？**
* 主要存储结构有邻接矩阵、邻接表、十字链表、邻接多重表
* 邻接矩阵的存储方式适合点数较少的稠密图，对于顶点多的点，会浪费大量空间。
* 邻接表用于弥补邻接矩阵的缺陷，但是使用起来比较耗费时间；
* 十字链表是有向图的一种链式存储结构；
* 邻接多重表是无向图的另一种链式存储方式；

### **图的遍历算法**
* 广度优先搜索(Breadth First Search)
    + 基本原理是（暴力搜索），首先访问起始顶点V，接着从V出发，依次访问V的各个未访问过的邻接顶点W1,W2,...,Wn，然后依次访问W1,W2,...,Wn的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为初始点，重复上述过程。
    + 广度优先算法采用队列的数据结构来存储未探索的结点，算法的收敛速度比较慢，需要更多的内存；
* 深度优先搜索(Depth First Search)
    + 基本原理是（回溯算法），首先访问图中某一起始顶点V，然后由V出发，访问与V邻接且未被访问的任一顶点W1，再访问与W1邻接且未被访问的任一顶点W2，重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的结点，若它还有邻接顶点未被访问过，则从该点开始，继续上述搜索过程，直至图中所有顶点均被访问过为止。
    + 深度优先搜索采用堆栈的数据结构来存储未探索的结点，算法的收敛速度比较快，需要更少的内存；
* 深度优先和广度优先搜索的时间复杂度都是O(E)，空间复杂度是O(V)；

### **图的遍历和树的遍历有哪些区别？**
* 图的遍历是指从图的某一点出发访问其余顶点，且使得每个顶点仅仅被访问依次。一般来说图的遍历有两种，深度优先算法和广度优先算法。
* 树的遍历是指依次对树中的每个结点访问一次且仅访问一次。二叉树的三种最重要的遍历方式分别称为前序遍历、中序遍历和后序遍历以及层次遍历。

### **什么是最小生成树？最小生成树的两种算法，时间复杂度是多少以及适用性**
* 最小生成树：（最小生成树不唯一）对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的那颗生成树，则T称为G的最小生成树。
* Prim（普里姆）算法：初始时从图中任取一顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入T；
* Kruskal（克鲁斯卡尔）算法：首先，将每个顶点放入其自身的数据集合中。然后，按照权值的升序来选择边。当选择每条边时，判断定义边的顶点是否在不同的数据集中。如果是，将此边插入最小生成树的集合中，同时，将集合中包含每个顶点的联合体取出，如果不是，就移动到下一条边。重复这个过程直到所有的边都探查过。
* Prim算法适合边稠密的图，时间复杂度是O(${n}^{2}$)，Kruskar算法适合边稀疏而顶点较多的图，时间复杂度是O(${nlog}_2n$)。

### **N个结点的二叉树的最小生成树有几条边？**
* N-1条边

### **迪杰斯特拉算法？弗洛伊德算法？**
* Dijkstra算法：求单源最短路径，即求图中某一顶点到其他各顶点的最短路径；
    + Dijkstra算法需要借助到三个主要的数据结构：
        - 集合S：用于记录已求得最短路径的顶点；
        - 数组dist[]: dist[i]表示从源点到第i个结点的最短路径长度；
        - 数组path[]: path[i]表示从源点到第i个结点的前驱结点，后续可以通过该数组获取到特定结点的最短路径；
    + Dijkstra算法主要采用了广度优先搜索策略，每一轮不断地根据权值查找最小值，并更新当前结点对应的dist和path数组，同时把每一轮中能够使得对应dist最小的结点放入S中（说明该节点的最短路径已经求出），直到所有结点均放入S中，算法结束。
    + Dijkstra算法遍历计算的结点较多，因此效率较低，时间复杂度是O(${n}^{2}$)，该算法无法计算有负权的图。
* Floyd算法：求任意两点之间的最短路径；
    + Floyd算法主要涉及的数据结构：
        - 二维数组map[i][j]: 表示结点i到结点j的最短距离；
    + Floyd算法主要运用动态规划的思想，对任意结点k，检查map[i][k]+map[k][j]<map[i][j]，若成立，则map[i][j]=map[i][k]+map[k][j]；因此，通过三层嵌套循环检查map数组中的k的情况；
    + Floyd算法的算法复杂度是O(${n}^{3}$)，相比Dijkstra算法，其能够计算有负权的图；

### **强连通图和连通图如何定义？非连通图如何遍历访问每一个结点？**
* 连通图：无向图中任意两个顶点都连通的图；
* 强连通图：是有向图中任意两个顶点都连通的图；
* 非连通图遍历：用循环遍历每一个连通分量，连通分量内与连通图遍历方法相同。

## 查找
### **阐述各种查找算法**
* 静态查找算法
    + 顺序查找：
        - 基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到给定条件的元素，则返回查找失败的信息。
    + 二分查找：
        - 首先将给定的key值与表中中间位置的元素比较，若相等，则查找成功，返回改元素的存储位置；若不相等，则所需查找的元素只能在中间元素以外的前半部分或后半部分。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息；
        - 二分查找是一种十分高效的查找算法，时间复杂度为O(${log}_2n$)；
        - 缺点是二分查找依赖于顺序表结构，即数组，因此查找的数据量不宜太大也不宜太小，太大会耗费内存，太小效率又太低了；同时二分查找也只针对于有序数据的查找；
        - 二分查找的实质是构建了一颗二叉排序树，因此使用二分查找时，如果需要插入和删除操作，通过二叉排序树会更加方便。为了提高查找效率，还可以进一步使用二叉平衡树(AVL)
        - 实际应用：ip地址获取定位
    + 分块查找：
        - 将查找分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。
        - 分块查找的过程分为两步：第一步是再索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找。
* 动态查找包括
    + 二叉排序树
    + 平衡二叉树

### **B树和B+树**
* B树和B+树的出现是为了解决磁盘查询的问题，磁盘I/O操作的效率比较低，而且磁盘中的海量数据不能同时加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的结点。如果应用二叉查找树的话，那么由于树的深度过大，会造成磁盘I/O读写过于频繁，导致效率低下。因此，为了减少磁盘I/O的次数，必须降低树的深度，将“瘦高”的树变得矮胖。
* B+树相比B树
    + B+树的数据都存储在叶子结点上，而B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息；
    + B+树的优势在于查找效率上，因为B+树的中间结点只有索引信息，而没有包含索引指向的数据，这意味着同样大小的磁盘页可以容纳更多结点元素，在相同的数据量下，B+树更加“矮胖”，I/O操作更少；
    + B树的查找只需找到匹配元素即可，最好的情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而B+树每次必须查找到叶子结点，性能稳定。


### **哈希表的特点？构造哈希函数的方法有哪些？哈希表会不会发生冲突？有哪些解决的方法？散列表的查找效率（平均查找长度）取决于什么？散列表适合存储什么样的数据？**
* 哈希表的特点：访问速度快、数据无序存储、可能会出现数据碰撞；
* 构造哈希函数的方法：直接定址法、数字分析法、平方取中法；
* 没有完美的散列函数，不管是MD5、SHA还是CRC也都无法完全避免散列冲突；
* 解决散列冲突的方法：开放地址法（线性探测法、平方探测法、再散列法、伪随机序列法）、拉链法；
* 散列表的查找效率取决于散列函数，、处理冲突的方法和装填因子；
* 散列表适合存储需要快速查找且关键字很少重复甚至不重复的数据。

### **采用何种数据结构能过够通过学号查找姓名的速度最快？**
* Hash表，查找效率为O(1);
* Hash表的其他应用：Word文档中的单词拼写检查功能；

### **如何找出出现次数最多的数据？**
* 对所有数据建立Hash表，然后对其中相同数据进行计数；

## 排序

### **描述学过的排序算法？**
* **插入排序**：直接插入排序，折半插入排序，希尔插入排序；
    + 插入排序算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置，将其插入，并保证已排序区间数据一直有序。不断重复上述过程
    + 直接插入排序：
        - ![avatar](picture/直接插入排序.jpg)
        - 查找出L(i)在L[1...i-1]中插入的位置k；
        - 将L[k...i-1]中所有元素依次向后移一个位置；
        - 将L[i]复制到L[k];
        - ```C
          void InsertSort(ElemType A[], int n){
              int i,j;
              for(i=2;i<=n;i++){
                  if(A[i]<A[i-1]){
                        A[0] = A[i];
                        for(j=i-1;A[0]<A[j];--j)
                            A[j+1] = A[j];
                        A[j+1] = A[0];
                  }
              }
          }
          ```
    + 折半插入排序是对直接插入排序的优化，在确认插入位置这个过程中，直接插入排序算法是采用遍历法，但是折半插入排序算法，在这里利用二分查找的策略，能够有效减少比较元素的次数；
        - 折半插入排序的时间复杂度仍然是O(${n}^{2}$)，但是对于数据量不大的排序表，能够表现出更好的性能；
    + 希尔排序的基本思想是：先将待排序表分割成若干形如L[i,i+d,i+2d,...,i+kd]的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序；希尔排序的时间复杂度约为O(${n}^{1.3}$)，最坏的情况是O(${n}^{2}$)
    + 插入排序是原地排序算法，空间复杂度是O(1)，时间复杂度是O(${n}^{2}$);
    + tips：虽然插入排序和冒泡排序时间复杂度一样，都是O(${n}^{2}$)，但是实际上插入排序的效率更高，因为冒泡排序在代码实现上比插入排序更加复杂，插入排序在元素交换过程中只需要一次赋值操作，而冒泡排序需要三次赋值操作；
* 交换排序：冒泡排序，快速排序；
    + **冒泡排序**算法：
        - 从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完；
        - 依次重复上述过程，直至遍历过后没有任何一对元素发生交换；
        ```C
            void BubbleSort(ElemTyppe A[], int n){
                for(i=0;i<n-1;i++>){
                    flag = false;           //标注本趟冒泡是否发生交换的标志
                    for(j=n-1;j>i;j--){     //一趟冒泡过程
                        if(A[j-1]>A[j]){    //若为逆序
                            swap(A[j-1],A[j]); //交换顺序
                            flag = ture;
                        }
                    if(flag = false)
                        return;         //若一趟遍历过后没有发生交换，说明表已经有序；
                    }
                }
            }
            ```
    + 冒泡排序的时间复杂度是O(${n}^{2}$)，空间复杂度是O(1)；
    + tips：冒泡排序算法是一种稳定的排序算法；
    + **快速排序**算法：
        - 快速排序算法主要利用分治思想，在待排序表L[1...n]中任取一个元素pivot作为基准，通过一趟排序将待排序表划为独立的两部分L[1...k-1]和L[k+1...n]，使得L[1...k-1]中的所有元素小于pivot，L[k+1...n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为**一趟快速排序**，然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。
        - 快速排序算法的划分操作：核心思想是选取pivot（选取pivot之后，值虽然还在，但是这里相当于空出来位置了，可以用于保存需要交换的数据），把小于pivot的放在左边，大于pivot的放在右边，设置两个指针，low和high分别指向序列的最左边和最右边，从最右的high开始，如果大于就把指针前移，如果小于就把high指向的数据赋值到pivot的位置。对于low同理，如果小于就后移指针，如果大于就把指针指向的数据赋值到刚刚high空出来的位置；
        - ```C 
            int Partition(int A[],int low,int high){
                int pivot=A[low];     //一般选取当前表中第一个元素设为基准，对表进行划分
                while(low<high){      //循环跳出条件
                    while(low<high&&A[high]>=pivot) --high;
                    A[low]=A[high];   //将比基准值小的元素移动到左端
                    while(low<high&&A[low]<=pivot) low++;
                    A[high]=A[low];   //将比基准值大的元素移动到右端
                }
                A[low]=pivot;         //放回基准值元素
                return low;           //返回存放基准值的最终位置
            } 
            
            void QuickSort(int A[],int low,int high){
                if(low<high){
                    int pivotpos = Partition(A,low,high);
                    QuickSort(A,low,pivotpos-1);
                    QUickSort(A,povotpos+1,high);
                }
            }
        - 快速排序算法的空间复杂度是O(${log}_2n$)，时间复杂度是O(${nlog}_2n$)，快速排序是所有内部排序算法中平均性能最优的排序算法。
* 选择排序：简单选择排序，堆排序；
    + **简单选择排序**：
        - 假设排序表为L[1...n]，第i趟排序即从L[i...n]中选择关键字最小的元素与L[i]交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。
        - ```C
            void SelectSort(ElemType A[],int n){
                for(i=0;i<n-1;i++){                  //一共进行n-1趟
                    min = i;                         //记录最小元素位置
                    for(j=i+1;j<n;j++)
                        if(A[j]<A[min])
                            min = j;
                    if(min!=i)
                        swap(A[i],A[min]);
              }
          }
          ```
    + **堆排序**：
        - 首先将存放在L[1...n]中的n个元素建成初始堆，由于堆本身的特点，堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大堆顶的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。以此往复，直到堆中仅剩下一个元素为止。
        - 堆排序的时间复杂度是O(${nlog}_2n$)，空间复杂度是O(1);
    + 选择排序的时间复杂度是O(${n}^{2}$)，空间复杂度是O(1);
* **归并排序**：
    + 二路归并排序基本思想：假定待排序表含有n个记录，则可将其视为n个有序的子表，每个子表的长度为1，然后两两归并，得到[n/2]个长度为2或1的有序表：继续两两归并……以此往复，直到合成一个长度为n的有序表为止，这种排序方法称为2路归并排序；
    + 归并排序算法使用了分治思想，将大问题分解成小的子问题来解决。小的子问题解决了，大问题也就迎刃而解了。
    + ```C
        /*王道上归并算法的Merge函数，不是很赞同A[k]=B[i++]这种写法，纯粹为了简洁性，把代码的规范和可读性丢了*/
        void Merge(ElemType A[],int low,int mid,int high){
        //将表A的两段A[low...mid]和A[mid+1...high]各自有序，将它们合并成一个有序表
            for(int k=low; k<=low;k++)
                B[k]=A[k];
            //复制A中所有的元素到B
            for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
                if(B[i]<=B[j])                 //比较B的左右两段中的元素
                    A[k]=B[i++];               //将较小的值复制到A中
                else A[k]=B[j++];
            }
            while(i<=mid) A[k++]=B[i++];       //若第一个表未检测完，复制
            while(j<=high) A[k++]=B[j++];      //若第二个表未检测完，复制
            //两个while循环实际上只会进入一个
        }

        void MergeSort(ElemType A[],int low,int high){
        //2路归并算法
            if(low<high){
                int mid=(low+high)/2;
                MergeSort(A,low,mid);
                MergeSort(A,mid+1,high);
                Merge(A,low,mid,high);
            }
        }
        ```
    + 归并排序的空间复杂度O(n)，时间复杂度是O(${nlog}_2n$)，同时也是一种稳定的排序算法；
* **基数排序、计数排序、桶排序**：
    + 三种排序算法均利用了桶的概念（桶内元素采用快速排序），但对桶的使用方法上有明显差异：
        - 基数排序：根据键值的每位数字来分配桶；
        - 计数排序：每个桶只存储单一键值；
        - 桶排序：每个桶存储一定范围的数值；
    + 三种线性排序算法对要求排序的数据有比较苛刻的需求，应用不是非常广泛；
### **快速排序和冒泡排序的原理，其空间复杂度是多少？**
* 快速排序：选择基准（一般选取第一个），根据基准将序列分成两半，对两半进行递归，重复前边的操作。空间复杂度：平均情况O(logn)
* 冒泡排序：从后往前两两比较相邻元素值，若为逆序，则交换，一趟排序后最小的会放第一个位置。或从前往后凉凉比较元素值，逆序就交换，一趟排序后最大的会放到最后。空间复杂度：O(1)
### **稳定排序的优势**
* 稳定排序在整数中可能看不出来优势，但是对于一些按照key值排列的对象，稳定的排序算法在处理这些数据时候能够保持对象之间的关系不被破坏；
* 如电商下单和价格排序问题。
### **怎样在数组中快速找到其中的最大值**
* 构建大根堆结构。
### **在有序的情况下进行快速排序的时间复杂度是多少**
* 快速排序最坏的情况就是选取了基准后，划分的两个区域元素数量是n-1和0，此时时间复杂度为O(${n}^{2}$)
### **用数组存储的数字进行排序，如何选择排序算法**
* 若n比较小，采用直接插入排序或者简单插入排序；若数组基本有序，采用直接插入或者冒泡排序；
* 若n比较大，采用快速排序、堆排序和归并排序；
* 若n非常大，采用基数排序；



